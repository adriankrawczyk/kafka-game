-- game_logic.ksql

-- Ustawienie serializacji danych na JSON
SET 'auto.offset.reset' = 'earliest';

-- === STRUMIENIE WEJŚCIOWE (ZDARZENIA) ===

-- 1. Strumień akcji graczy (wysyłane przez game_client.py)
-- Klucz: player_id
CREATE STREAM PLAYER_ACTIONS (
    player_id VARCHAR KEY,
    username VARCHAR,
    action VARCHAR,
    dx DOUBLE,
    dy DOUBLE,
    timestamp BIGINT
) WITH (
    KAFKA_TOPIC = 'player_actions',
    VALUE_FORMAT = 'JSON',
    PARTITIONS = 1
);

-- 2. Strumień zdarzeń o zebranych punktach (wysyłane przez logic_server.py)
-- Klucz: dot_id
CREATE STREAM DOT_COLLECTION_EVENTS (
    dot_id VARCHAR KEY,
    player_id VARCHAR,
    dot_type VARCHAR
) WITH (
    KAFKA_TOPIC = 'dot_collection_events',
    VALUE_FORMAT = 'JSON',
    PARTITIONS = 1
);

-- 3. Strumień zdarzeń o nowo wygenerowanych punktach (wysyłane przez dot_generator.py)
-- Klucz: dot_id
CREATE STREAM DOT_GENERATION_EVENTS (
    id VARCHAR KEY,
    x INT,
    y INT,
    type VARCHAR
) WITH (
    KAFKA_TOPIC = 'dot_generation_events',
    VALUE_FORMAT = 'JSON',
    PARTITIONS = 1
);


-- === TABELE STANU (ZMATERIALIZOWANE WIDOKI) ===

-- 1. Tabela przechowująca aktualny stan wszystkich punktów na planszy
-- Każdy nowy punkt z DOT_GENERATION_EVENTS tworzy wiersz.
-- Każde zdarzenie z DOT_COLLECTION_EVENTS z tym samym kluczem (dot_id) i wartością NULL usuwa wiersz (tombstone record).
CREATE TABLE DOTS_TABLE WITH (KAFKA_TOPIC='dots_state', PARTITIONS=1, VALUE_FORMAT='JSON') AS
SELECT
    id AS dot_id,
    LATEST_BY_OFFSET(x) AS x,
    LATEST_BY_OFFSET(y) AS y,
    LATEST_BY_OFFSET(type) AS type
FROM DOT_GENERATION_EVENTS
GROUP BY id;

-- 2. Tabela przechowująca aktualny stan każdego gracza (pozycja, wynik itd.)
CREATE TABLE PLAYERS_TABLE (
    player_id VARCHAR PRIMARY KEY,
    username VARCHAR,
    x DOUBLE,
    y DOUBLE,
    score INT,
    shared_score_contribution INT, -- ile ten gracz wniósł do puli wspólnej
    last_seen BIGINT
) WITH (
    KAFKA_TOPIC = 'players_state',
    VALUE_FORMAT = 'JSON',
    PARTITIONS = 1
);

-- 3. Tabela pomocnicza do agregacji wyniku wspólnego
CREATE TABLE SHARED_SCORE_TABLE AS
SELECT
    'global_score' AS score_key,
    SUM(shared_score_contribution) AS total_shared_score
FROM PLAYERS_TABLE
GROUP BY 'global_score';


-- === STRUMIEŃ WYJŚCIOWY (KOMPLETNY STAN GRY) ===

-- To jest strumień, którego nasłuchują klienci gry.
-- Łączy on (JOIN) wszystkie tabele stanu w jeden spójny obiekt.
-- UWAGA: Z powodu ograniczeń ksqlDB, nie możemy połączyć wielu tabel w jedną.
-- Dlatego serwer logiki (`logic_server.py`) będzie musiał połączyć te dane.
-- Poniżej tworzymy strumień z samym stanem graczy do dalszego przetwarzania.

-- Strumień wyjściowy stanu gry, który będą konsumować klienci i serwery logiki.
-- W tym uproszczonym modelu, głównym strumieniem stanu będzie `players_state` i `dots_state`.
-- Bardziej zaawansowane byłoby stworzenie serwisu, który łączy te strumienie w jeden `game_state`.
-- Dla celów projektu, klient może nasłuchiwać obu.